#![feature(generators, generator_trait)]

use std::ops::{Generator, GeneratorState};

/// Create an iterator with Haskell's list-comprehension-like notation.
///
/// ## Syntax
///
///  - iter_compr = `iter_compr![` expression `;` qualifier (`,` qualifier)* `]`
///  - qualifier = generator | local-declaration | guard
///  - generator = pattern `in` expression
///  - local-declaration = `let` pattern `=` expression
///  - guard = expression
///
/// ## Differences with Haskell's List Comprehension
///
///  - Uses `;` instead of `|` to separate the first expression and qualifiers.
///  - Uses `in` instead of `<-` to separate the pattern and the expression in a generator.
///
/// # Examples
///
/// ## Simple
/// ```
/// #![feature(generators)]
/// #[macro_use]
/// extern crate iter_compr;
///
/// fn main() {
///     let mut iter = iter_compr![x; x in 0..3];
///
///     assert_eq!(iter.next(), Some(0));
///     assert_eq!(iter.next(), Some(1));
///     assert_eq!(iter.next(), Some(2));
///     assert_eq!(iter.next(), None);
/// }
/// ```
///
/// ## Complex
///
/// ```
/// #![feature(generators)]
/// #[macro_use]
/// extern crate iter_compr;
///
/// fn main() {
///     let mut iter = iter_compr![(x, y, z); x in 0..6, y in 1..x, x % y == 0, let z = x / y];
///
///     assert_eq!(iter.next(), Some((2, 1, 2)));
///     assert_eq!(iter.next(), Some((3, 1, 3)));
///     assert_eq!(iter.next(), Some((4, 1, 4)));
///     assert_eq!(iter.next(), Some((4, 2, 2)));
///     assert_eq!(iter.next(), Some((5, 1, 5)));
///     assert_eq!(iter.next(), None);
/// }
/// ```
///
/// ## Infinite iterator
///
/// ```
/// #![feature(generators)]
/// #[macro_use]
/// extern crate iter_compr;
///
/// fn main() {
///     let mut iter = iter_compr![(x, y); x in 0.., y in "abc".chars()];
///
///     assert_eq!(iter.next(), Some((0, 'a')));
///     assert_eq!(iter.next(), Some((0, 'b')));
///     assert_eq!(iter.next(), Some((0, 'c')));
///     assert_eq!(iter.next(), Some((1, 'a')));
///     assert_eq!(iter.next(), Some((1, 'b')));
///     assert_eq!(iter.next(), Some((1, 'c')));
///     assert_eq!(iter.next(), Some((2, 'a')));
///     assert_eq!(iter.next(), Some((2, 'b')));
///     assert_eq!(iter.next(), Some((2, 'c')));
///     // ...
/// }
/// ```
#[macro_export]
macro_rules! iter_compr {
    ($exp:expr ; $($tt:tt)*) => {
        $crate::GeneratorIterator::new(|| {
            iter_compr_internal!($exp; $($tt)*)
        })
    };
}

#[doc(hidden)]
#[macro_export]
macro_rules! iter_compr_internal {
    ($exp:expr; ) => {
        yield $exp;
    };

    ($exp:expr; let $pat:pat = $exp2:expr) => {
        {
            let $pat = $exp2;
            iter_compr_internal!($exp;)
        }
    };

    ($exp:expr; let $pat:pat = $exp2:expr, $($tt:tt)*) => {
        {
            let $pat = $exp2;
            iter_compr_internal!($exp; $($tt)*)
        }
    };

    ($exp:expr; $pat:pat in $gen:expr) => {
        for $pat in $gen {
            iter_compr_internal!($exp;)
        }
    };

    ($exp:expr; $pat:pat in $gen:expr, $($tt:tt)*) => {
        for $pat in $gen {
            iter_compr_internal!($exp; $($tt)*)
        }
    };

    ($exp:expr; $guard:expr) => {
        if $guard {
            iter_compr_internal!($exp;)
        }
    };

    ($exp:expr; $guard:expr, $($tt:tt)*) => {
        if $guard {
            iter_compr_internal!($exp; $($tt)*)
        }
    };
}

/// An iterator enumerating values that is generated by the generator.
///
/// GeneratorIterator is used internally by macro `iter_compr`.
pub struct GeneratorIterator<G> {
    gen: G,
}

impl<G> GeneratorIterator<G> {
    /// Create an iterator with a generator.
    pub fn new(gen: G) -> Self {
        Self { gen }
    }
}

impl<G, T> Iterator for GeneratorIterator<G>
where
    G: Generator<Yield = T, Return = ()>,
{
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        if let GeneratorState::Yielded(v) = unsafe { self.gen.resume() } {
            Some(v)
        } else {
            None
        }
    }
}
